<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home on a rant of my adventures</title><link>https://blog.caprinux.com/</link><description>Recent content in Home on a rant of my adventures</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Wed, 27 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.caprinux.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Reversing a Playstation X Application?</title><link>https://blog.caprinux.com/posts/ctfs/2023/wgmy2023/</link><pubDate>Wed, 27 Dec 2023 00:00:00 +0000</pubDate><guid>https://blog.caprinux.com/posts/ctfs/2023/wgmy2023/</guid><description>WGMY 2024 &amp;ndash; RmRf &amp;ldquo;What happened to my system? It has been working perfectly for more than 20 years.&amp;rdquo;
We are given a zip that contains a bin and cue file. If we run strings, we see that it points to a playstation/PSX program.
I extracted the ISO file by running binwalk --extract rmrf.bin. From the ISO file, we can extract the playstation EXE by using unar.
rmrf &amp;gt; binwalk --extract rmrf.</description></item><item><title>Blahaj CTF Pwn Writeups</title><link>https://blog.caprinux.com/posts/ctfs/2023/blahaj-ctf/</link><pubDate>Sun, 03 Dec 2023 00:00:00 +0000</pubDate><guid>https://blog.caprinux.com/posts/ctfs/2023/blahaj-ctf/</guid><description>Blahaj CTF was an entry-level CTF that was targeted at secondary school and JC students in Singapore. Having not touched pwn for awhile, the pwn challenges were fun, refreshing and even challenging. There were a total of 4 pwn challenges, 3 simpler ones and 1 challenging one. The writeups for the 4 challenges are below and in increasing difficulty.
This writeup aims to be dummy-friendly, and a good guide for absolute beginners to learn binary exploitation.</description></item><item><title>Life Update -- new blog!</title><link>https://blog.caprinux.com/posts/ctfs/2023/life-update/</link><pubDate>Tue, 21 Nov 2023 00:00:00 +0000</pubDate><guid>https://blog.caprinux.com/posts/ctfs/2023/life-update/</guid><description>hey, to whoever reads this, it&amp;rsquo;s been awhile :&amp;quot;) how&amp;rsquo;s life?
for myself, life has been absolutely shitty recently &amp;#x1f912; i&amp;rsquo;m currently going through alot, and i&amp;rsquo;m currently finding ways to cope with things &amp;ndash; exploring and occupying myself with new stuff
it&amp;rsquo;s been over a year since i have last updated my blog (not sure if anyone reads it but whatever ü§≠), and i&amp;rsquo;ve modified the entire website (yay dark mode!</description></item><item><title>Window of Opportunity -- Intro to Kernel Exploitation</title><link>https://blog.caprinux.com/posts/ctfs/2023/ictf-window-of-opportunity/</link><pubDate>Tue, 25 Jul 2023 05:59:12 +0000</pubDate><guid>https://blog.caprinux.com/posts/ctfs/2023/ictf-window-of-opportunity/</guid><description>Imaginary CTF 2023 has just ended and it once again did not disappoint. The CTF featured a variety of fun and interesting challenges. Kudos to the organizers for yet another successful event.
One of the interesting challenges that I solved this year was window-of-opportunity, which is a kernelspace pwn challenge. In this writeup, I will share my thought processes and hopefully bring you some insights or new knowledge into the world of kernelspace!</description></item><item><title>SEETF 2023 Pwn Writeups</title><link>https://blog.caprinux.com/posts/ctfs/2023/seetf2023-pwns/</link><pubDate>Mon, 12 Jun 2023 05:59:12 +0000</pubDate><guid>https://blog.caprinux.com/posts/ctfs/2023/seetf2023-pwns/</guid><description>SEETF Brief Writeup on Pwns Shellcode As A Service As indicated by the challenge name and description, we have to write shellcode that will be executed by the program.
We are given an initial write of 6 bytes long, which allows us to get a second stage write. There is open, read seccomp, preventing us from printing flag.
We can write a loop in assembly to read one character at a time, and terminate if the character is incorrect.</description></item><item><title>Weapon Safety -- Windows Pwn</title><link>https://blog.caprinux.com/posts/ctfs/2022/cyberleague-weapon-safety/</link><pubDate>Sun, 26 Mar 2023 05:59:12 +0000</pubDate><guid>https://blog.caprinux.com/posts/ctfs/2022/cyberleague-weapon-safety/</guid><description>Weapon Safety Initial Analysis We are provided with a 64-bit windows executable. If we throw it into IDA, we can see that it did not manage to find the main function.
However we have the _start function and we can easily find this main function ourselves by either looking for strings in the program and finding cross references
or clicking into the start function and finding the main function (somewhere in the last block), which can be identified by the function call right after 3 arguments are being loaded (r8, rdx, ecx).</description></item><item><title>Flag Checker (pwn) -- War Games Malaysia</title><link>https://blog.caprinux.com/posts/ctfs/2022/wgmy-flag-checker/</link><pubDate>Sat, 31 Dec 2022 05:59:12 +0000</pubDate><guid>https://blog.caprinux.com/posts/ctfs/2022/wgmy-flag-checker/</guid><description>FlagChecker pwn challenge from wgmy2022
FlagChecker.zip ‚îú‚îÄ‚îÄ bin ‚îÇ¬†‚îú‚îÄ‚îÄ flag_checker ‚îÇ¬†‚îî‚îÄ‚îÄ flag.txt ‚îú‚îÄ‚îÄ ctf.xinetd ‚îú‚îÄ‚îÄ docker-compose.yml ‚îú‚îÄ‚îÄ Dockerfile ‚îî‚îÄ‚îÄ start.sh Setup Since we are provided with the Dockerfile, we can start by setting up our environment (extracting the LIBC and LD) to mimic the environment of the server.
Upon setting up our docker, we can spawn a shell as shown below
‚ùØ docker exec -it wgmy-flag_checker-1 /bin/bash root@ef917d02df99:/home/ctf# ldd flag_checker # show the dependencies linux-vdso.</description></item><item><title>TISC 2022</title><link>https://blog.caprinux.com/posts/ctfs/2022/tisc-2022/</link><pubDate>Sat, 10 Sep 2022 00:00:00 +0000</pubDate><guid>https://blog.caprinux.com/posts/ctfs/2022/tisc-2022/</guid><description>The Challenge The Information Security Challenge (TISC) is an annual Capture The Flag (CTF) competition hosted by the Centre for Strategic Infocomm Technologies (CSIT) in Singapore.
The CTF features a series of 10 levels over the span of 2 weeks, covering various CTF topics including, but not limited to, Web Pen-testing, Forensics, Reverse Engineering, Binary Exploitation, Cryptography, and Mobile Security.
In order to unlock levels, you had to clear all the levels before.</description></item><item><title>Imaginary CTF 2022 Writeups</title><link>https://blog.caprinux.com/posts/ctfs/2022/imaginaryctf-2022/</link><pubDate>Sat, 23 Jul 2022 00:00:00 +0000</pubDate><guid>https://blog.caprinux.com/posts/ctfs/2022/imaginaryctf-2022/</guid><description>Currently serving conscription. These are writeups of challenges that I solved on a tablet from my army camp üëçüëç
ret2win (100 pts)¬†- 266 solves Jumping around in memory is hard. I&amp;rsquo;ll give you some help so that you can pwn this! Author: Eth007
vuln vuln.c
Analysis #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; int win() { FILE *fp; char flag[255]; fp = fopen(&amp;#34;flag.txt&amp;#34;, &amp;#34;r&amp;#34;); fgets(flag, 255, fp); puts(flag); } char **return_address; int main() { char buf[16]; return_address = buf+24; setvbuf(stdout,NULL,2,0); setvbuf(stdin,NULL,2,0); puts(&amp;#34;Welcome to ret2win!</description></item><item><title>Miscellaneous CTF Writeups</title><link>https://blog.caprinux.com/posts/ctfs/2022/miscellaneous-ctf-writeups/</link><pubDate>Mon, 06 Jun 2022 05:59:12 +0000</pubDate><guid>https://blog.caprinux.com/posts/ctfs/2022/miscellaneous-ctf-writeups/</guid><description>redirecting you to my old ctf-writeup github repository in 1 second</description></item><item><title>dCTF - cache (pwn)</title><link>https://blog.caprinux.com/posts/ctfs/2022/dctf-cache/</link><pubDate>Sun, 13 Feb 2022 00:00:00 +0000</pubDate><guid>https://blog.caprinux.com/posts/ctfs/2022/dctf-cache/</guid><description>After many lazy months and a long hiatus, I finally found some time to sit down and see through a slightly less than trivial pwn challenge.
Competed under the team xiao zhu zhus alongside my other xiao zhu zhu in the team.
Overview Can you catch me?
Flag format: CTF{sha256}
Files: vuln.zip
Trivial Preview Right off the bat, we are provided with the vulnerable program vuln as well as the libc used for this program in the remote server.</description></item><item><title>zh3ro CTF - more printf (pwn)</title><link>https://blog.caprinux.com/posts/ctfs/2021/zh3ro-more-printf/</link><pubDate>Mon, 07 Jun 2021 00:00:00 +0000</pubDate><guid>https://blog.caprinux.com/posts/ctfs/2021/zh3ro-more-printf/</guid><description>Challenge Description printf();
nc pwn.zh3r0.cf 2222
Attached: printf.tar.gz
Author - hk
Overview Extracting the tar archive, we are provided with a binary, the source code, and libc-2.27.so.
/* gcc -o more-printf -fstack-protector-all more-printf.c */ #include &amp;lt;stdint.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; FILE *fp; char *buffer; uint64_t i = 0x8d9e7e558877; _Noreturn main() { /* Just to save some of your time */ uint64_t *p; p = &amp;amp;p; /* Chall */ setbuf(stdin, 0); buffer = (char *)malloc(0x20 + 1); fp = fopen(&amp;#34;/dev/null&amp;#34;, &amp;#34;wb&amp;#34;); fgets(buffer, 0x1f, stdin); if (i !</description></item><item><title>ictf - A little birdie once told me... (pwn)</title><link>https://blog.caprinux.com/posts/ctfs/2021/ictf-birdie/</link><pubDate>Mon, 31 May 2021 00:00:00 +0000</pubDate><guid>https://blog.caprinux.com/posts/ctfs/2021/ictf-birdie/</guid><description>I thought this was a good challenge so I decided to do a writeup on it. This challenge was from ictf 2021 May batch of challenges.
ictf is a discord server to get daily CTF (Capture the Flag) challenges aimed mostly towards beginners (with occasional difficult challenges). Moreover, no sign-up is required, everything is on discord.
Overview If at first you don&amp;rsquo;t succeed, try try again&amp;hellip; Connect with nc 140.238.222.141 42000.</description></item><item><title>dCTF - Formats Last Theorem(pwn)</title><link>https://blog.caprinux.com/posts/ctfs/2021/dctf-formats-last-theorem/</link><pubDate>Thu, 27 May 2021 00:00:00 +0000</pubDate><guid>https://blog.caprinux.com/posts/ctfs/2021/dctf-formats-last-theorem/</guid><description>Challenge Description I dare you to hook the malloc
nc dctf-chall-formats-last-theorem.westeurope.azurecontainer.io 7482
formats_last_theorem Dockerfile
Overview We are provided with the binary and a docker file. We first check the security features of the binary.
[*] &amp;apos;/media/sf_dabian/Challenges/dctf/pwn/lft/formats_last_theorem&amp;apos; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Connecting to the service, we get prompted for an input, which seems to continuously loop and prompt for more input.</description></item><item><title>dCTF - Hotel ROP (pwn)</title><link>https://blog.caprinux.com/posts/ctfs/2021/dctf-hotel-rop/</link><pubDate>Mon, 24 May 2021 00:00:00 +0000</pubDate><guid>https://blog.caprinux.com/posts/ctfs/2021/dctf-hotel-rop/</guid><description>This writeup will be more PwnTools-oriented since this writeup will also be cross-posted onto Pwntools Blog.
Today, we will be looking at a pwn challenge from dCTF 2021 which features ret2libc exploitation with a little twist of a PIE-enabled binary. The following PwnTools features will be introduced here:
pwnlib.rop to help us craft ROP chains pwnlib.elf to make finding addresses quick and easy and many more little modules from pwntools to help us pwn faster ~ Challenge Description They say programmers&amp;rsquo; dream is California.</description></item><item><title>3kCTF - MasterC (pwn)</title><link>https://blog.caprinux.com/posts/ctfs/2021/3kctf-masterc/</link><pubDate>Thu, 20 May 2021 00:00:00 +0000</pubDate><guid>https://blog.caprinux.com/posts/ctfs/2021/3kctf-masterc/</guid><description>Threaded win? is that even a thing?
nc masterc.2021.3k.ctf.to 9999
Attachment: masterc.tgz
Overview We are provided with the libc, ld, source code and the binary itself.
Running checksec on the binary, we see all security features green
[*] &amp;#39;/media/sf_dabian/Challenges/3kctf/masterc/masterc/bin/masterc&amp;#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Enter the size : Enter the number of tries : Enter your guess : We are prompted with 3 inputs upon running the binary.</description></item><item><title>Cyberthon 2021 - APCafe (pwn)</title><link>https://blog.caprinux.com/posts/ctfs/2021/cyberthon-apcafe/</link><pubDate>Wed, 19 May 2021 05:59:12 +0000</pubDate><guid>https://blog.caprinux.com/posts/ctfs/2021/cyberthon-apcafe/</guid><description>We&amp;rsquo;ve received intel that APOCALYPSE is running a cafe as a front for their illegal activities. Although it seems like a regular cafe on the outside, serving local favourites such as Kopi-O, Milo, and Yuan Yang, we believe that something more sinister is going on. Could u try to find a way to break in so we can investigate further?
Interact with the service at: aiodmb3uswokssp2pp7eum8qwcsdf52r.ctf.sg:30101
Note: once you get a shell, the flag.</description></item><item><title>Cyberthon 2021 - APCDB (pwn)</title><link>https://blog.caprinux.com/posts/ctfs/2021/cyberthon-apcdb/</link><pubDate>Wed, 19 May 2021 05:59:12 +0000</pubDate><guid>https://blog.caprinux.com/posts/ctfs/2021/cyberthon-apcdb/</guid><description>We&amp;rsquo;ve found a network service that seems to be posing as a fake directory of APOCALYPSE members. Although it doesn&amp;rsquo;t seem to be hooked up to any actual database, it does look a tad vulnerable. Could u try to break in anyway? Who knows, access to this server might come in useful.
Interact with the service at: aiodmb3uswokssp2pp7eum8qwcsdf52r.ctf.sg:30201
Note: once you get a shell, the flag.txt can be found in the user&amp;rsquo;s home directory.</description></item><item><title>Cyberthon 2021 - PlaceHolder (pwn)</title><link>https://blog.caprinux.com/posts/ctfs/2021/cyberthon-placeholder/</link><pubDate>Wed, 19 May 2021 05:59:12 +0000</pubDate><guid>https://blog.caprinux.com/posts/ctfs/2021/cyberthon-placeholder/</guid><description>Hohoho seems like one of the APOCALYPSE agents messed up big time. Seems this agent went to deploy his/her code for testing and completely forgot to bring down the network service. This careless agent even forgot to private the repository containing the test code, so we&amp;rsquo;ve managed to obtain the source for the entire project, dockerfile and all. We&amp;rsquo;ve provided you with everything that we&amp;rsquo;ve found, so can you get the flag from their server?</description></item><item><title>README</title><link>https://blog.caprinux.com/pwn/prologue/overview/</link><pubDate>Thu, 01 Jan 0009 00:00:01 +0000</pubDate><guid>https://blog.caprinux.com/pwn/prologue/overview/</guid><description>Pwn for Fun and Profit is a progressive tutorial series that aims to be noob-friendly enough for anyone to dive in, and equip them with the skills to come out with substantial knowledge on The Art of Pwn.
I wrote this tutorial to provide people with the things I hope I knew / was told when I first started off on my pwn journey.
I hope that you enjoy this tutorial as much as I enjoyed writing it, and that it was useful to you.</description></item><item><title>What is Pwn?</title><link>https://blog.caprinux.com/pwn/prologue/what_is_pwn/</link><pubDate>Thu, 01 Jan 0009 00:00:00 +0000</pubDate><guid>https://blog.caprinux.com/pwn/prologue/what_is_pwn/</guid><description>Binary Exploitation &amp;hellip; really comes down to finding a vulnerability in the program and exploiting it to gain control of a shell or modifying the program&amp;rsquo;s functions. ~ ctf101
In pwn challenges, we are often provided with a vulnerable Linux-ELF binary, whereby we will have to find a vulnerability and exploit it to obtain a flag.
Concepts/Techniques: Understanding C programs The C Library (LIBC) Assembly Registers Calling Conventions Binary Security No eXecute (NX) Address Space Layout Randomization (ASLR) &amp;amp; Position Independent Executable (PIE) Stack Canaries/Cookies Relocation Read-Only (RELRO) Reverse-Engineering Decompilation The Stack Buffer Buffer Overflow Pwntools Global Offset Table (GOT) Format String Exploitation Shellcoding Return Oriented Programming Ret2win Ret2Libc SIGRop Ret2csu What do I need to know?</description></item><item><title>How does C Programming Work?</title><link>https://blog.caprinux.com/pwn/innerworkings/how_does_c_programming_work/</link><pubDate>Tue, 01 Jan 0008 00:00:09 +0000</pubDate><guid>https://blog.caprinux.com/pwn/innerworkings/how_does_c_programming_work/</guid><description>New Concepts Covered What is a buffer? C Library Analyzing C Code Buffer A buffer is any allocated space in memory where data (often user input) can be stored.
Analysis Consider a simple C program as such. Let&amp;rsquo;s try to figure out what it does.
#include &amp;lt;stdio.h&amp;gt; int main() { char name[10]; puts(&amp;#34;What is your name?&amp;#34;); scanf(&amp;#34;%10s&amp;#34;, &amp;amp;name); printf(&amp;#34;Hello %s&amp;#34;, &amp;amp;name); return 0; } #include &amp;lt;stdio.h&amp;gt;
On line 1, the program initializes the C library which allows you to use functions from the C library such as the puts, printf, scanf that you see in the program.</description></item><item><title>How does Assembly work?</title><link>https://blog.caprinux.com/pwn/innerworkings/how_does_assembly_work/</link><pubDate>Tue, 01 Jan 0008 00:00:08 +0000</pubDate><guid>https://blog.caprinux.com/pwn/innerworkings/how_does_assembly_work/</guid><description>New concepts Covered Registers Stack Assembly Instructions Calling Conventions Please watch this video on x86 Assembly, it&amp;rsquo;s really amazing. Registers A register is a location within the processor that is able to store data, much like RAM. Unlike RAM however, accesses to registers are effectively instantaneous.
There are actually 17 registers in an AMD64 architecture, aka 64 bit.
14 of which are general purpose registers: rax, rbx, rcx, rdx, rdi, rsi, r8, r9, r10, r11, r12, r13, r14, r15</description></item><item><title>The Tables of the Binary</title><link>https://blog.caprinux.com/pwn/innerworkings/pltgot/</link><pubDate>Tue, 01 Jan 0008 00:00:07 +0000</pubDate><guid>https://blog.caprinux.com/pwn/innerworkings/pltgot/</guid><description>Procedure Linkage Table PLT stands for Procedure Linkage Table which is, put simply, used to call external procedures/functions whose address isn&amp;rsquo;t known in the time of linking, and is left to be resolved by the dynamic linker at run time.
Simply put, PLT contains the little function instructions which is called when you call a function such as scanf.
It retrieves the data and addresses from the GOT and jumps to it.</description></item><item><title>Binary Decompilation</title><link>https://blog.caprinux.com/pwn/innerworkings/decompilation/</link><pubDate>Tue, 01 Jan 0008 00:00:06 +0000</pubDate><guid>https://blog.caprinux.com/pwn/innerworkings/decompilation/</guid><description>Disassembly When approaching pwn challenges, most of them provide a binary, but do not give you the source code or assembly code. How do you tackle such challenges then?
You will now learn disassembly, which allows you to convert a binary back to its assembly code.
There is a convenient linux command line tool called objdump which allows us to easily convert our C code back to assembly.
We can run objdump with the -d flag which signifies disassemble, and the -M intel to display our instructions in assembly syntax.</description></item><item><title>The x86 Memory</title><link>https://blog.caprinux.com/pwn/innerworkings/memory/</link><pubDate>Tue, 01 Jan 0008 00:00:05 +0000</pubDate><guid>https://blog.caprinux.com/pwn/innerworkings/memory/</guid><description>This will be a very brief explanation of how the memory works in a program.
This is how the memory layout looks like in a program:
Let&amp;rsquo;s get straight to our example
Example Consider the following program:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; char data[1000] = &amp;#34;Hi I go to the .data section of the memory because I am a global variable with a defined value aka initialzed variables&amp;#34;; char bss[100]; int also_inside_bss; // These 2 variables are in the bss section of the memory because they are global variables with no defined values aka uninitialised variables void main() { char hello[100] = &amp;#34;Hi I go to the stack because I&amp;#39;m a variable initialized inside a function&amp;#34;; char *heap; heap = malloc(100); strcpy(heap, &amp;#34;Hi I am in the heap because I have been malloc&amp;#39;ed&amp;#34;); } And this is how it all comes together!</description></item><item><title>no eXecute (NX)</title><link>https://blog.caprinux.com/pwn/checksec/nx/</link><pubDate>Mon, 01 Jan 0007 00:00:09 +0000</pubDate><guid>https://blog.caprinux.com/pwn/checksec/nx/</guid><description>New Concepts Covered Check Binary Security No eXecute Check Binary Security You need PwnTools (pip install pwntools) OR Checksec Tool (sudo apt-get install checksec)
Simply run checksec &amp;lt;binary-name&amp;gt; in order to list the security in the binary.
For example,
No eXecute The No eXecute or the NX bit (also known as Data Execution Prevention or DEP) marks certain areas of the program as not executable, meaning that stored input or data cannot be executed as code.</description></item><item><title>Stack Canary</title><link>https://blog.caprinux.com/pwn/checksec/canary/</link><pubDate>Mon, 01 Jan 0007 00:00:08 +0000</pubDate><guid>https://blog.caprinux.com/pwn/checksec/canary/</guid><description>Stack Canary Stack Canaries are a secret value placed on the stack which changes every time the program is started. Prior to a function return, the stack canary is checked and if it appears to be modified, the program exits immediately.
It is also important to note that canaries always have a null byte.
Let&amp;rsquo;s consider our previously written C program.
Assuming we made a mistake when coding our program, we do not limit our input, which means that nasty nasty things could happen if we write more than what our name[10] can hold!</description></item><item><title>Binary Randomization (ASLR/PIE)</title><link>https://blog.caprinux.com/pwn/checksec/aslr_pie/</link><pubDate>Mon, 01 Jan 0007 00:00:07 +0000</pubDate><guid>https://blog.caprinux.com/pwn/checksec/aslr_pie/</guid><description>ASLR Address Space Layout Randomization (or ASLR) is the randomization of the place in memory where the program, shared libraries, the stack, and the heap are.
What this means basically is that every single time you rerun the binary, your functions, stack and heap addresses will have different addresses each time.
However, the only thing that stays constant is the offsets between each address.
Hence, if you are able to calculate the ASLR base address during that run of the binary, you can possibly calculate all addresses easily.</description></item><item><title>Relocation Read-Only (RELRO)</title><link>https://blog.caprinux.com/pwn/checksec/relro/</link><pubDate>Mon, 01 Jan 0007 00:00:06 +0000</pubDate><guid>https://blog.caprinux.com/pwn/checksec/relro/</guid><description>RELRO Relocation Read-Only (or RELRO) is a security measure which makes some binary sections read-only.
This means that you are unable to write or execute functions in these &amp;lsquo;binary sections&amp;rsquo;.
RELRO can be Partial or Full. We will focus more on Full RELRO for the entirety of this tutorial series.
Partial Partial RELRO is the default setting in GCC, and nearly all binaries you will see have at least partial RELRO.</description></item><item><title>Stack Buffer Overflow</title><link>https://blog.caprinux.com/pwn/stack/bof/</link><pubDate>Sun, 01 Jan 0006 00:00:09 +0000</pubDate><guid>https://blog.caprinux.com/pwn/stack/bof/</guid><description>Finally! We are getting started on the real stuff üòè
If you have followed along this series so far, congratulations on coming thus far!
You have only just started on your road to becoming a pwn god and I hope you enjoy your journey :)
Buffer Overflow Concept Consider the following program.
// gcc secret.c -o secret #include &amp;lt;stdio.h&amp;gt; int main() { char secret[20] = &amp;#34;you cant touch me&amp;#34;; char name[10]; puts(&amp;#34;What is your name?</description></item><item><title>Stack Buffer Overflow Practice Solutions</title><link>https://blog.caprinux.com/pwn/stack/bofsolutions/</link><pubDate>Sun, 01 Jan 0006 00:00:08 +0000</pubDate><guid>https://blog.caprinux.com/pwn/stack/bofsolutions/</guid><description>Before you read the challenge solution below, you should have at least attempted the challenges in the previous page.
WhiteHacks 2021 - Puddi Puddi Overview Decompiling the binary in Ghidra, we obtain the following decompiled code:
void print_flag(void) { FILE *__stream; size_t __nmemb; char *__s; char *flag; size_t data_size; FILE *file; flag = fopen(&amp;#34;flag.txt&amp;#34;,&amp;#34;rb&amp;#34;); if (flag == (FILE *)0x0) { puts(&amp;#34;flag.txt not found!&amp;#34;); exit(1); } return; } int main(void) { int iVar1; char input [32]; char size [5]; size = 0x4147454d; // MEGA size[4] = &amp;#39;\0&amp;#39;; printf(&amp;#34;Do you like pudding?</description></item><item><title>Return2Win Technique</title><link>https://blog.caprinux.com/pwn/stack/ret2win/</link><pubDate>Sun, 01 Jan 0006 00:00:07 +0000</pubDate><guid>https://blog.caprinux.com/pwn/stack/ret2win/</guid><description>Prologue Recap:
RIP is the instruction pointer which is a 64-bit register that holds the memory address of the instruction to be executed next.
Stack grows downwards. Newly popped data will be at lower addresses. Simply put, a stack is a tower but upside down :p
Each function has its own stack layout, denominated by rbp (base pointer) and rsp (stack pointer).
In order to understand how to ret2win, we have to learn more about what the stack layout as well as what happens behind the scenes when functions are called.</description></item><item><title>Return Oriented Programming</title><link>https://blog.caprinux.com/pwn/rop/whatisrop/</link><pubDate>Sat, 01 Jan 0005 00:00:09 +0000</pubDate><guid>https://blog.caprinux.com/pwn/rop/whatisrop/</guid><description>Return Oriented Programming (or ROP) is the idea of chaining together small snippets of assembly with stack control to cause the program to do more complex things.
As we saw in Buffer Overflows, having stack control can be very powerful since it allows us to overwrite saved instruction pointers to control the flow of the program and call programs that was never called in the function.
However, some functions may require arguments that we have to pass, whilst sometimes we may not even have a win() or a give_shell() function at all.</description></item><item><title>ROP Gadgets</title><link>https://blog.caprinux.com/pwn/rop/ropgadgets/</link><pubDate>Sat, 01 Jan 0005 00:00:08 +0000</pubDate><guid>https://blog.caprinux.com/pwn/rop/ropgadgets/</guid><description>Remember in the previous chapter, we exploited this program;
// gcc -no-pie win.c -o win #include &amp;lt;stdio.h&amp;gt; int win() { printf(&amp;#34;you can&amp;#39;t call me ;)&amp;#34;) } int vuln() { char name[10]; gets(&amp;amp;name); return 0; } int main() { vuln(); return 0; } What if now we tweak it a little bit to add arguments to win();
// gcc -no-pie win.c -o win #include &amp;lt;stdio.h&amp;gt; int win(int argument) { if (argument == 0xdeadbeef) { printf(&amp;#34;You Win!</description></item><item><title>Return To Libc - Concept</title><link>https://blog.caprinux.com/pwn/rop/ret2libc1/</link><pubDate>Sat, 01 Jan 0005 00:00:07 +0000</pubDate><guid>https://blog.caprinux.com/pwn/rop/ret2libc1/</guid><description>Recap Address Space Layout Randomization (or ASLR) is the randomization of the place in memory where the program, shared libraries, the stack, and the heap are.
printf() calls printf @ PLT printf @ PLT calls printf @ GOT printf @ GOT contains a single address to printf @ LIBC, which it jumps to. Program successfully executes printf() and returns! ROP Gadgets are small snippets of assembly in the binary, that we can use to control the program</description></item><item><title>Return To Libc - Automated by Pwntools</title><link>https://blog.caprinux.com/pwn/rop/ret2libc2/</link><pubDate>Sat, 01 Jan 0005 00:00:06 +0000</pubDate><guid>https://blog.caprinux.com/pwn/rop/ret2libc2/</guid><description>This is a continuation of Return 2 LIBC Part 1. If you have not read it, please read it before continuing.
Recap In the last part of Ret2Libc, we exploited this simple program (albeit painfully) from SECCON 2021;
// gcc src.c -no-pie -fno-stack-protector -o chall -Wall -Wextra #include &amp;lt;stdio.h&amp;gt; int main() { char str[0x100]; gets(str); puts(str); } This time, we will do it without finding any addresses from all over the place.</description></item><item><title>About</title><link>https://blog.caprinux.com/pages/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.caprinux.com/pages/about/</guid><description>i&amp;rsquo;m your typical singaporean pre-university student, currently in conscription.
this blog serves as a way to keep myself accountable for my own learning, as well as to share random cool stuff that i find with my readers.
if you would like to contact me, you can email me here.</description></item></channel></rss>