<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pwn for Fun and Profit on a rant of my adventures</title><link>https://archive.elmo.sg/pwn/</link><description>Recent content in Pwn for Fun and Profit on a rant of my adventures</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Thu, 01 Jan 0009 00:00:01 +0000</lastBuildDate><atom:link href="https://archive.elmo.sg/pwn/index.xml" rel="self" type="application/rss+xml"/><item><title>README</title><link>https://archive.elmo.sg/pwn/prologue/overview/</link><pubDate>Thu, 01 Jan 0009 00:00:01 +0000</pubDate><guid>https://archive.elmo.sg/pwn/prologue/overview/</guid><description>Pwn for Fun and Profit is a progressive tutorial series that aims to be noob-friendly enough for anyone to dive in, and equip them with the skills to come out with substantial knowledge on The Art of Pwn.
I wrote this tutorial to provide people with the things I hope I knew / was told when I first started off on my pwn journey.
I hope that you enjoy this tutorial as much as I enjoyed writing it, and that it was useful to you.</description></item><item><title>What is Pwn?</title><link>https://archive.elmo.sg/pwn/prologue/what_is_pwn/</link><pubDate>Thu, 01 Jan 0009 00:00:00 +0000</pubDate><guid>https://archive.elmo.sg/pwn/prologue/what_is_pwn/</guid><description>Binary Exploitation &amp;hellip; really comes down to finding a vulnerability in the program and exploiting it to gain control of a shell or modifying the program&amp;rsquo;s functions. ~ ctf101
In pwn challenges, we are often provided with a vulnerable Linux-ELF binary, whereby we will have to find a vulnerability and exploit it to obtain a flag.
Concepts/Techniques: Understanding C programs The C Library (LIBC) Assembly Registers Calling Conventions Binary Security No eXecute (NX) Address Space Layout Randomization (ASLR) &amp;amp; Position Independent Executable (PIE) Stack Canaries/Cookies Relocation Read-Only (RELRO) Reverse-Engineering Decompilation The Stack Buffer Buffer Overflow Pwntools Global Offset Table (GOT) Format String Exploitation Shellcoding Return Oriented Programming Ret2win Ret2Libc SIGRop Ret2csu What do I need to know?</description></item><item><title>How does C Programming Work?</title><link>https://archive.elmo.sg/pwn/innerworkings/how_does_c_programming_work/</link><pubDate>Tue, 01 Jan 0008 00:00:09 +0000</pubDate><guid>https://archive.elmo.sg/pwn/innerworkings/how_does_c_programming_work/</guid><description>New Concepts Covered What is a buffer? C Library Analyzing C Code Buffer A buffer is any allocated space in memory where data (often user input) can be stored.
Analysis Consider a simple C program as such. Let&amp;rsquo;s try to figure out what it does.
#include &amp;lt;stdio.h&amp;gt; int main() { char name[10]; puts(&amp;#34;What is your name?&amp;#34;); scanf(&amp;#34;%10s&amp;#34;, &amp;amp;name); printf(&amp;#34;Hello %s&amp;#34;, &amp;amp;name); return 0; } #include &amp;lt;stdio.h&amp;gt;
On line 1, the program initializes the C library which allows you to use functions from the C library such as the puts, printf, scanf that you see in the program.</description></item><item><title>How does Assembly work?</title><link>https://archive.elmo.sg/pwn/innerworkings/how_does_assembly_work/</link><pubDate>Tue, 01 Jan 0008 00:00:08 +0000</pubDate><guid>https://archive.elmo.sg/pwn/innerworkings/how_does_assembly_work/</guid><description>New concepts Covered Registers Stack Assembly Instructions Calling Conventions Please watch this video on x86 Assembly, it&amp;rsquo;s really amazing. Registers A register is a location within the processor that is able to store data, much like RAM. Unlike RAM however, accesses to registers are effectively instantaneous.
There are actually 17 registers in an AMD64 architecture, aka 64 bit.
14 of which are general purpose registers: rax, rbx, rcx, rdx, rdi, rsi, r8, r9, r10, r11, r12, r13, r14, r15</description></item><item><title>The Tables of the Binary</title><link>https://archive.elmo.sg/pwn/innerworkings/pltgot/</link><pubDate>Tue, 01 Jan 0008 00:00:07 +0000</pubDate><guid>https://archive.elmo.sg/pwn/innerworkings/pltgot/</guid><description>Procedure Linkage Table PLT stands for Procedure Linkage Table which is, put simply, used to call external procedures/functions whose address isn&amp;rsquo;t known in the time of linking, and is left to be resolved by the dynamic linker at run time.
Simply put, PLT contains the little function instructions which is called when you call a function such as scanf.
It retrieves the data and addresses from the GOT and jumps to it.</description></item><item><title>Binary Decompilation</title><link>https://archive.elmo.sg/pwn/innerworkings/decompilation/</link><pubDate>Tue, 01 Jan 0008 00:00:06 +0000</pubDate><guid>https://archive.elmo.sg/pwn/innerworkings/decompilation/</guid><description>Disassembly When approaching pwn challenges, most of them provide a binary, but do not give you the source code or assembly code. How do you tackle such challenges then?
You will now learn disassembly, which allows you to convert a binary back to its assembly code.
There is a convenient linux command line tool called objdump which allows us to easily convert our C code back to assembly.
We can run objdump with the -d flag which signifies disassemble, and the -M intel to display our instructions in assembly syntax.</description></item><item><title>The x86 Memory</title><link>https://archive.elmo.sg/pwn/innerworkings/memory/</link><pubDate>Tue, 01 Jan 0008 00:00:05 +0000</pubDate><guid>https://archive.elmo.sg/pwn/innerworkings/memory/</guid><description>This will be a very brief explanation of how the memory works in a program.
This is how the memory layout looks like in a program:
Let&amp;rsquo;s get straight to our example
Example Consider the following program:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; char data[1000] = &amp;#34;Hi I go to the .data section of the memory because I am a global variable with a defined value aka initialzed variables&amp;#34;; char bss[100]; int also_inside_bss; // These 2 variables are in the bss section of the memory because they are global variables with no defined values aka uninitialised variables void main() { char hello[100] = &amp;#34;Hi I go to the stack because I&amp;#39;m a variable initialized inside a function&amp;#34;; char *heap; heap = malloc(100); strcpy(heap, &amp;#34;Hi I am in the heap because I have been malloc&amp;#39;ed&amp;#34;); } And this is how it all comes together!</description></item><item><title>no eXecute (NX)</title><link>https://archive.elmo.sg/pwn/checksec/nx/</link><pubDate>Mon, 01 Jan 0007 00:00:09 +0000</pubDate><guid>https://archive.elmo.sg/pwn/checksec/nx/</guid><description>New Concepts Covered Check Binary Security No eXecute Check Binary Security You need PwnTools (pip install pwntools) OR Checksec Tool (sudo apt-get install checksec)
Simply run checksec &amp;lt;binary-name&amp;gt; in order to list the security in the binary.
For example,
No eXecute The No eXecute or the NX bit (also known as Data Execution Prevention or DEP) marks certain areas of the program as not executable, meaning that stored input or data cannot be executed as code.</description></item><item><title>Stack Canary</title><link>https://archive.elmo.sg/pwn/checksec/canary/</link><pubDate>Mon, 01 Jan 0007 00:00:08 +0000</pubDate><guid>https://archive.elmo.sg/pwn/checksec/canary/</guid><description>Stack Canary Stack Canaries are a secret value placed on the stack which changes every time the program is started. Prior to a function return, the stack canary is checked and if it appears to be modified, the program exits immediately.
It is also important to note that canaries always have a null byte.
Let&amp;rsquo;s consider our previously written C program.
Assuming we made a mistake when coding our program, we do not limit our input, which means that nasty nasty things could happen if we write more than what our name[10] can hold!</description></item><item><title>Binary Randomization (ASLR/PIE)</title><link>https://archive.elmo.sg/pwn/checksec/aslr_pie/</link><pubDate>Mon, 01 Jan 0007 00:00:07 +0000</pubDate><guid>https://archive.elmo.sg/pwn/checksec/aslr_pie/</guid><description>ASLR Address Space Layout Randomization (or ASLR) is the randomization of the place in memory where the program, shared libraries, the stack, and the heap are.
What this means basically is that every single time you rerun the binary, your functions, stack and heap addresses will have different addresses each time.
However, the only thing that stays constant is the offsets between each address.
Hence, if you are able to calculate the ASLR base address during that run of the binary, you can possibly calculate all addresses easily.</description></item><item><title>Relocation Read-Only (RELRO)</title><link>https://archive.elmo.sg/pwn/checksec/relro/</link><pubDate>Mon, 01 Jan 0007 00:00:06 +0000</pubDate><guid>https://archive.elmo.sg/pwn/checksec/relro/</guid><description>RELRO Relocation Read-Only (or RELRO) is a security measure which makes some binary sections read-only.
This means that you are unable to write or execute functions in these &amp;lsquo;binary sections&amp;rsquo;.
RELRO can be Partial or Full. We will focus more on Full RELRO for the entirety of this tutorial series.
Partial Partial RELRO is the default setting in GCC, and nearly all binaries you will see have at least partial RELRO.</description></item><item><title>Stack Buffer Overflow</title><link>https://archive.elmo.sg/pwn/stack/bof/</link><pubDate>Sun, 01 Jan 0006 00:00:09 +0000</pubDate><guid>https://archive.elmo.sg/pwn/stack/bof/</guid><description>Finally! We are getting started on the real stuff üòè
If you have followed along this series so far, congratulations on coming thus far!
You have only just started on your road to becoming a pwn god and I hope you enjoy your journey :)
Buffer Overflow Concept Consider the following program.
// gcc secret.c -o secret #include &amp;lt;stdio.h&amp;gt; int main() { char secret[20] = &amp;#34;you cant touch me&amp;#34;; char name[10]; puts(&amp;#34;What is your name?</description></item><item><title>Stack Buffer Overflow Practice Solutions</title><link>https://archive.elmo.sg/pwn/stack/bofsolutions/</link><pubDate>Sun, 01 Jan 0006 00:00:08 +0000</pubDate><guid>https://archive.elmo.sg/pwn/stack/bofsolutions/</guid><description>Before you read the challenge solution below, you should have at least attempted the challenges in the previous page.
WhiteHacks 2021 - Puddi Puddi Overview Decompiling the binary in Ghidra, we obtain the following decompiled code:
void print_flag(void) { FILE *__stream; size_t __nmemb; char *__s; char *flag; size_t data_size; FILE *file; flag = fopen(&amp;#34;flag.txt&amp;#34;,&amp;#34;rb&amp;#34;); if (flag == (FILE *)0x0) { puts(&amp;#34;flag.txt not found!&amp;#34;); exit(1); } return; } int main(void) { int iVar1; char input [32]; char size [5]; size = 0x4147454d; // MEGA size[4] = &amp;#39;\0&amp;#39;; printf(&amp;#34;Do you like pudding?</description></item><item><title>Return2Win Technique</title><link>https://archive.elmo.sg/pwn/stack/ret2win/</link><pubDate>Sun, 01 Jan 0006 00:00:07 +0000</pubDate><guid>https://archive.elmo.sg/pwn/stack/ret2win/</guid><description>Prologue Recap:
RIP is the instruction pointer which is a 64-bit register that holds the memory address of the instruction to be executed next.
Stack grows downwards. Newly popped data will be at lower addresses. Simply put, a stack is a tower but upside down :p
Each function has its own stack layout, denominated by rbp (base pointer) and rsp (stack pointer).
In order to understand how to ret2win, we have to learn more about what the stack layout as well as what happens behind the scenes when functions are called.</description></item><item><title>Return Oriented Programming</title><link>https://archive.elmo.sg/pwn/rop/whatisrop/</link><pubDate>Sat, 01 Jan 0005 00:00:09 +0000</pubDate><guid>https://archive.elmo.sg/pwn/rop/whatisrop/</guid><description>Return Oriented Programming (or ROP) is the idea of chaining together small snippets of assembly with stack control to cause the program to do more complex things.
As we saw in Buffer Overflows, having stack control can be very powerful since it allows us to overwrite saved instruction pointers to control the flow of the program and call programs that was never called in the function.
However, some functions may require arguments that we have to pass, whilst sometimes we may not even have a win() or a give_shell() function at all.</description></item><item><title>ROP Gadgets</title><link>https://archive.elmo.sg/pwn/rop/ropgadgets/</link><pubDate>Sat, 01 Jan 0005 00:00:08 +0000</pubDate><guid>https://archive.elmo.sg/pwn/rop/ropgadgets/</guid><description>Remember in the previous chapter, we exploited this program;
// gcc -no-pie win.c -o win #include &amp;lt;stdio.h&amp;gt; int win() { printf(&amp;#34;you can&amp;#39;t call me ;)&amp;#34;) } int vuln() { char name[10]; gets(&amp;amp;name); return 0; } int main() { vuln(); return 0; } What if now we tweak it a little bit to add arguments to win();
// gcc -no-pie win.c -o win #include &amp;lt;stdio.h&amp;gt; int win(int argument) { if (argument == 0xdeadbeef) { printf(&amp;#34;You Win!</description></item><item><title>Return To Libc - Concept</title><link>https://archive.elmo.sg/pwn/rop/ret2libc1/</link><pubDate>Sat, 01 Jan 0005 00:00:07 +0000</pubDate><guid>https://archive.elmo.sg/pwn/rop/ret2libc1/</guid><description>Recap Address Space Layout Randomization (or ASLR) is the randomization of the place in memory where the program, shared libraries, the stack, and the heap are.
printf() calls printf @ PLT printf @ PLT calls printf @ GOT printf @ GOT contains a single address to printf @ LIBC, which it jumps to. Program successfully executes printf() and returns! ROP Gadgets are small snippets of assembly in the binary, that we can use to control the program</description></item><item><title>Return To Libc - Automated by Pwntools</title><link>https://archive.elmo.sg/pwn/rop/ret2libc2/</link><pubDate>Sat, 01 Jan 0005 00:00:06 +0000</pubDate><guid>https://archive.elmo.sg/pwn/rop/ret2libc2/</guid><description>This is a continuation of Return 2 LIBC Part 1. If you have not read it, please read it before continuing.
Recap In the last part of Ret2Libc, we exploited this simple program (albeit painfully) from SECCON 2021;
// gcc src.c -no-pie -fno-stack-protector -o chall -Wall -Wextra #include &amp;lt;stdio.h&amp;gt; int main() { char str[0x100]; gets(str); puts(str); } This time, we will do it without finding any addresses from all over the place.</description></item></channel></rss>